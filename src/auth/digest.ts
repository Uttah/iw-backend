import * as crypto from 'crypto';
import {notNull, getRandomInRange} from '../util/common';

// The common digest configuration.
const config = {
    alg: 'sha256',   // hashing alg.
    hashSize: 64,    // size of the generated hash
    saltSize: 32,    // salt size
    iterations: 100  // iterations number
};

/**
 * Hash a password.
 *
 * @param {!String} password.
 */
export async function hash(password:string):Promise<Buffer> {
    notNull(password, 'Password');
    // generate a salt.
    const salt = await createSalt(config.saltSize, config.hashSize);
    const hash = await crypto.pbkdf2Sync(password.normalize('NFKC'), salt, config.iterations, config.hashSize, config.alg) ;
    const buf = new Buffer(hash.length + salt.length);
    salt.copy(buf, 0);
    hash.copy(buf, salt.length);
    return buf;
}

/**
 * Verify a password.
 *
 * @param {!String} password
 * @param {!Buffer} source Buffer containing hash and salt as generated by hashPassword.
 */
export async function verify(password:string, source:Buffer):Promise<boolean> {
    notNull(password, 'Password');
    notNull(source, 'Source buffer');
    // extract the salt and hash from the combined buffer
    const salt = source.slice(0, config.saltSize);
    const hash = source.toString('binary', config.saltSize);

    // verify the salt and hash against the password
    const verify = await crypto.pbkdf2Sync(password.normalize('NFKC'), salt, config.iterations, config.hashSize, config.alg); 
    return verify.toString('binary') === hash;
}

// Generate salt data buffer.
async function createSalt(saltSize:number, hashSize:number):Promise<Buffer> {
    const salt = await crypto.pseudoRandomBytes(saltSize);
    const arr = createShuffleArray(saltSize, hashSize);
    shuffle(salt, arr);
    return salt;
}

// Produces the data array for shuffle.
function createShuffleArray(arrLen:number, maxRange:number):number[] {
    const data = new Array();
    for (let i = 0; i < arrLen; i++) {
        const val = getRandomInRange(0, maxRange);
        if (!valid(val)|| data.indexOf(val) >= 0)
            continue;
        data.push(val);
    }
    return data;
}

// Check if passed number is valid.
function valid(num):boolean {
    return (num > 0 && num % 2 == 0);
}

// Shuffle the given buffer with values from the data array.
function shuffle(buf:Buffer, arr:number[]):void {
    let last = undefined;
    for (let i = 1; i <= arr.length; i++) {
        const val = arr[i];
        if (last != 1 && val <= 3) {
            buf.reverse();
            last = 1;
            continue;
        }
        if (last != 2 && val % 8 == 0) {
            buf.swap64();
            last = 2;
            continue;
        }
        if (last != 3 && val % 4 == 0) {
            buf.swap32();
            last = 3;
            continue;
        }
        if (last != 4 && val % 2 == 0) {
            buf.swap16();
            last = 4;
        }
    }
}