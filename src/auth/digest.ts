import * as crypto from 'crypto';

// The digest configuration.
const config = {
    alg: 'sha256',    // hashing alg.
    hashBytes: 64,    // size of the generated hash
    saltBytes: 32,    // salt size
    iterations: 100   // iterations number
};

/**
 * Hash a password.
 *
 * @param {!String} password.
 */
export async function hash(password:string):Promise<Buffer> {
    // generate a salt.
    const salt = await crypto.pseudoRandomBytes(config.saltBytes);  
    const hash = await crypto.pbkdf2Sync(password, salt, config.iterations, config.hashBytes, config.alg) ;
    const buf = new Buffer(hash.length + salt.length);
    salt.copy(buf, 0);
    hash.copy(buf, salt.length);
    return buf;
}

/**
 * Verify a password.
 *
 * @param {!String} password
 * @param {!Buffer} source Buffer containing hash and salt as generated by hashPassword.
 */
export async function verify(password:string, source:Buffer):Promise<boolean> {
    // extract the salt and hash from the combined buffer
    const salt = source.slice(0, config.saltBytes);
    const hash = source.toString('binary', config.saltBytes);

    // verify the salt and hash against the password
    const verify = await crypto.pbkdf2Sync(password, salt, config.iterations, config.hashBytes, config.alg); 
    return verify.toString('binary') === hash;
}